#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: EmeraldGlass_DRuntime

#include "Basic.hpp"

#include "EmeraldGlass_DRuntime_classes.hpp"
#include "EmeraldGlass_DRuntime_parameters.hpp"


namespace SDK
{

// Function EmeraldGlass_DRuntime.EmeraldGlassIceWallChunk.AttachActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AEmeraldGlassIceWallChunk*>&ChunksInMyWall                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            SupportingActors                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           DirectBase                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmeraldGlassIceWallChunk::AttachActors(const TArray<class AEmeraldGlassIceWallChunk*>& ChunksInMyWall, const TArray<class AActor*>& SupportingActors, class AActor* DirectBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmeraldGlassIceWallChunk", "AttachActors");

	Params::EmeraldGlassIceWallChunk_AttachActors Parms{};

	Parms.ChunksInMyWall = std::move(ChunksInMyWall);
	Parms.SupportingActors = std::move(SupportingActors);
	Parms.DirectBase = DirectBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function EmeraldGlass_DRuntime.EmeraldGlassIceWallChunk.FindSupportingActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>&                  InOutSupportingActors                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const bool                              bAllowIceWallsAsSupportingActors                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AEmeraldGlassIceWallChunk*>&ChunksInMyWall                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AEmeraldGlassIceWallChunk::FindSupportingActors(TArray<class AActor*>& InOutSupportingActors, const bool bAllowIceWallsAsSupportingActors, const TArray<class AEmeraldGlassIceWallChunk*>& ChunksInMyWall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmeraldGlassIceWallChunk", "FindSupportingActors");

	Params::EmeraldGlassIceWallChunk_FindSupportingActors Parms{};

	Parms.InOutSupportingActors = std::move(InOutSupportingActors);
	Parms.bAllowIceWallsAsSupportingActors = bAllowIceWallsAsSupportingActors;
	Parms.ChunksInMyWall = std::move(ChunksInMyWall);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InOutSupportingActors = std::move(Parms.InOutSupportingActors);
}


// Function EmeraldGlass_DRuntime.EmeraldGlassIceWallChunk.IsIceWallAllowedToOverlapActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEmeraldGlassIceWallChunk::IsIceWallAllowedToOverlapActor(const class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmeraldGlassIceWallChunk", "IsIceWallAllowedToOverlapActor");

	Params::EmeraldGlassIceWallChunk_IsIceWallAllowedToOverlapActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EmeraldGlass_DRuntime.FortControllerComponent_SereneYard.AddTrackedInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABuildingGameplayActor*           TrackedInstance                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_SereneYard::AddTrackedInstance(class ABuildingGameplayActor* TrackedInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_SereneYard", "AddTrackedInstance");

	Params::FortControllerComponent_SereneYard_AddTrackedInstance Parms{};

	Parms.TrackedInstance = TrackedInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function EmeraldGlass_DRuntime.FortControllerComponent_SereneYard.RemoveOldestTrackedInstance
// (Final, Native, Public, BlueprintCallable)

void UFortControllerComponent_SereneYard::RemoveOldestTrackedInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_SereneYard", "RemoveOldestTrackedInstance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function EmeraldGlass_DRuntime.FortControllerComponent_SereneYard.GetOldestTrackedInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABuildingGameplayActor*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABuildingGameplayActor* UFortControllerComponent_SereneYard::GetOldestTrackedInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_SereneYard", "GetOldestTrackedInstance");

	Params::FortControllerComponent_SereneYard_GetOldestTrackedInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EmeraldGlass_DRuntime.FortControllerComponent_SereneYard.GetTrackedInstanceCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFortControllerComponent_SereneYard::GetTrackedInstanceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_SereneYard", "GetTrackedInstanceCount");

	Params::FortControllerComponent_SereneYard_GetTrackedInstanceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function EmeraldGlass_DRuntime.SereneYardFunctionLibraryNative.GetIceChunkRelativeTransforms
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSubclassOf<class ABuildingGameplayActor>IceClass                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTransform>&              OutRelativeTransforms                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void USereneYardFunctionLibraryNative::GetIceChunkRelativeTransforms(const TSubclassOf<class ABuildingGameplayActor> IceClass, TArray<struct FTransform>& OutRelativeTransforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SereneYardFunctionLibraryNative", "GetIceChunkRelativeTransforms");

	Params::SereneYardFunctionLibraryNative_GetIceChunkRelativeTransforms Parms{};

	Parms.IceClass = IceClass;
	Parms.OutRelativeTransforms = std::move(OutRelativeTransforms);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutRelativeTransforms = std::move(Parms.OutRelativeTransforms);
}


// Function EmeraldGlass_DRuntime.SereneYardFunctionLibraryNative.NativeCheckSpawnValidity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSereneYardWeaponData&     WeaponData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector&                         InOutTargetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             CameraYaw                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bCheckForAllChunks                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<bool>*                           OutValidity                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<double>*                         OutOffsets                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutActorsBeingUsedAsBase                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// ESereneYardTargetingFailedReason*       OutFailureReason                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USereneYardFunctionLibraryNative::NativeCheckSpawnValidity(const struct FSereneYardWeaponData& WeaponData, struct FVector& InOutTargetLocation, const float CameraYaw, const bool bCheckForAllChunks, TArray<bool>* OutValidity, TArray<double>* OutOffsets, TArray<class AActor*>* OutActorsBeingUsedAsBase, ESereneYardTargetingFailedReason* OutFailureReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SereneYardFunctionLibraryNative", "NativeCheckSpawnValidity");

	Params::SereneYardFunctionLibraryNative_NativeCheckSpawnValidity Parms{};

	Parms.WeaponData = std::move(WeaponData);
	Parms.InOutTargetLocation = std::move(InOutTargetLocation);
	Parms.CameraYaw = CameraYaw;
	Parms.bCheckForAllChunks = bCheckForAllChunks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InOutTargetLocation = std::move(Parms.InOutTargetLocation);

	if (OutValidity != nullptr)
		*OutValidity = std::move(Parms.OutValidity);

	if (OutOffsets != nullptr)
		*OutOffsets = std::move(Parms.OutOffsets);

	if (OutActorsBeingUsedAsBase != nullptr)
		*OutActorsBeingUsedAsBase = std::move(Parms.OutActorsBeingUsedAsBase);

	if (OutFailureReason != nullptr)
		*OutFailureReason = Parms.OutFailureReason;

	return Parms.ReturnValue;
}


// Function EmeraldGlass_DRuntime.SereneYardFunctionLibraryNative.NativeFindBestValidHit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSereneYardWeaponData&     WeaponData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const TArray<struct FHitResult>&        HitResults                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutBestValidHit                                        (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool*                                   bOutTreatAsInvalidForVerticalTest                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFindHitClosestToCenterZ                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CenterZ                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckTooCloseForHeight                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckNotWalkable                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USereneYardFunctionLibraryNative::NativeFindBestValidHit(const struct FSereneYardWeaponData& WeaponData, const TArray<struct FHitResult>& HitResults, struct FHitResult* OutBestValidHit, bool* bOutTreatAsInvalidForVerticalTest, bool bFindHitClosestToCenterZ, float CenterZ, bool bCheckTooCloseForHeight, bool bCheckNotWalkable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SereneYardFunctionLibraryNative", "NativeFindBestValidHit");

	Params::SereneYardFunctionLibraryNative_NativeFindBestValidHit Parms{};

	Parms.WeaponData = std::move(WeaponData);
	Parms.HitResults = std::move(HitResults);
	Parms.bFindHitClosestToCenterZ = bFindHitClosestToCenterZ;
	Parms.CenterZ = CenterZ;
	Parms.bCheckTooCloseForHeight = bCheckTooCloseForHeight;
	Parms.bCheckNotWalkable = bCheckNotWalkable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutBestValidHit != nullptr)
		*OutBestValidHit = std::move(Parms.OutBestValidHit);

	if (bOutTreatAsInvalidForVerticalTest != nullptr)
		*bOutTreatAsInvalidForVerticalTest = Parms.bOutTreatAsInvalidForVerticalTest;

	return Parms.ReturnValue;
}


// Function EmeraldGlass_DRuntime.SereneYardFunctionLibraryNative.NativeTraceForSpawning
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSereneYardWeaponData&     WeaponData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector&                   StartLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector*                         outTargetLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutTreatAsInvalidForVerticalTest                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutNoHitsFound                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFindHitClosestToCenterZ                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseSphereTrace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckTooCloseForHeight                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCheckNotWalkable                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USereneYardFunctionLibraryNative::NativeTraceForSpawning(const struct FSereneYardWeaponData& WeaponData, const struct FVector& StartLocation, const struct FVector& EndLocation, struct FHitResult* OutHitResult, struct FVector* outTargetLocation, bool* bOutTreatAsInvalidForVerticalTest, bool* bOutNoHitsFound, bool bFindHitClosestToCenterZ, bool bUseSphereTrace, bool bCheckTooCloseForHeight, bool bCheckNotWalkable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SereneYardFunctionLibraryNative", "NativeTraceForSpawning");

	Params::SereneYardFunctionLibraryNative_NativeTraceForSpawning Parms{};

	Parms.WeaponData = std::move(WeaponData);
	Parms.StartLocation = std::move(StartLocation);
	Parms.EndLocation = std::move(EndLocation);
	Parms.bFindHitClosestToCenterZ = bFindHitClosestToCenterZ;
	Parms.bUseSphereTrace = bUseSphereTrace;
	Parms.bCheckTooCloseForHeight = bCheckTooCloseForHeight;
	Parms.bCheckNotWalkable = bCheckNotWalkable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResult != nullptr)
		*OutHitResult = std::move(Parms.OutHitResult);

	if (outTargetLocation != nullptr)
		*outTargetLocation = std::move(Parms.outTargetLocation);

	if (bOutTreatAsInvalidForVerticalTest != nullptr)
		*bOutTreatAsInvalidForVerticalTest = Parms.bOutTreatAsInvalidForVerticalTest;

	if (bOutNoHitsFound != nullptr)
		*bOutNoHitsFound = Parms.bOutNoHitsFound;

	return Parms.ReturnValue;
}


// Function EmeraldGlass_DRuntime.SereneYardFunctionLibraryNative.NativeUpdateTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSereneYardWeaponData&     WeaponData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector*                         outTargetLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESereneYardTargetingFailedReason*       OutFailureReason                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<bool>*                           OutValidity                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USereneYardFunctionLibraryNative::NativeUpdateTarget(const struct FSereneYardWeaponData& WeaponData, struct FVector* outTargetLocation, ESereneYardTargetingFailedReason* OutFailureReason, TArray<bool>* OutValidity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SereneYardFunctionLibraryNative", "NativeUpdateTarget");

	Params::SereneYardFunctionLibraryNative_NativeUpdateTarget Parms{};

	Parms.WeaponData = std::move(WeaponData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outTargetLocation != nullptr)
		*outTargetLocation = std::move(Parms.outTargetLocation);

	if (OutFailureReason != nullptr)
		*OutFailureReason = Parms.OutFailureReason;

	if (OutValidity != nullptr)
		*OutValidity = std::move(Parms.OutValidity);

	return Parms.ReturnValue;
}

}

